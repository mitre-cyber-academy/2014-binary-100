{"name":"buffer-overflow","description":"Installs/Configures buffer-overflow challenge.","long_description":"Name: Simple Buffer Overflow\n\nDescription: The user will be presented with a C program that takes input using gets(). Their objective will be to overflow the buffer so that they will overwrite the data contained by the variable named \"keyRequest\".\nThe \"keyRequest\" variable will then be sent to a server via a socket. The server will then check to see if the keyRequest is correct. If it is correct, the key will be transmitted back to the user.\nOtherwise, the message \"Nope.\" will be displayed. The correct password is \"MOSS\".\n\nNOTE: Server code is also included in the repository. This will be running on the server during the even itself. ALSO, we will need to edit the buff.c source code to match the hostname and the port of the server.\n\nKey: aSByZWFsbHkgaG9wZSBsaWZlIGdldHMgZWFzaWVyLi4u\n\nSolution: One way to solve this would be to use a scripting language to overflow the buffer. Example solution: python -c 'print \"A\"*88 + \"MOSS\"' | ./buff\n\nTo compile: We have to disable the overflow protection. During testing I had compiled using the following command:\n gcc -Wall -fno-stack-protector -D_FORTIFY_SOURCE=0 buff.c -o buff\n \n listener.c\n gcc -Wall -D_FORTIFY_SOURCE=0 listener.c -o listener\n \n Note: You may want to use -g compiler flag to debug the code.","maintainer":"MITRE","maintainer_email":"rbclark@mitre.org","license":"All rights reserved","platforms":{},"dependencies":{"apt":">= 0.0.0","unattended-upgrades":">= 0.0.0"},"recommendations":{},"suggestions":{},"conflicting":{},"providing":{},"replacing":{},"attributes":{},"groupings":{},"recipes":{},"version":"0.1.0"}